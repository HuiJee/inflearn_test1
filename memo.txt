해당 프로젝트 폴더까지 접근
./gradlew build 하면 프로젝트가 자동 build가 됨

./gradlew clean 하면 build가 사라짐

===============================================================================

<MVC와 템플릿 엔진>
    JSP, PHP - 템플릿 엔진
    html을 서버에서 프로그래밍 하여 동적으로 내리는 것
    이제 그 프로그래밍 방식을 MVC로 실행함(Model - View - Controller)


@Service 이런 어노테이션을 통해 의존성 주입을 하는 건
컴포넌트 스캔 방식이라고 함
해당 어느테이션이 아닌 실제는 @Component라고 한다.
(실제로 @Service안에 @Component가 있음)

스프링은 컨테이너에 빈을 등록할 때, 기본으로 싱글톤으로 등록함
(유일하게 하나만 등록해서 공유한다는 의미)
별도로 설정해서 아니게 할 수 있지만, 특별한 경우 아니면 그러지 않음

===============================================================================

1. @Autowired 해서 생성자로 만들어 주입하면 생성자 주입 (권장)
2. 그냥 객체 필드 자체에 붙이면 필드 주입 (노란줄 뜸 - 좋지 않음)
3. setter 만들어서 어노테이션하면 세터 주입

setter의 경우 누군가 설정을 할 수 있는 부분인데..
setter 주입을 하게 되면 임의의 변경이 일어날 수 있음

실무에서 주로 정형화된 컨트롤러, 서비스, 리포지토리 같은 코드는 컴포넌트 스캔 사용함.
정형화되지 않거나, 상황에 따라 구현 클래스를 변경해야 하면 설정을 통해 스프링 빈으로 등록함.
=> 예제처럼 데이터 저장소 선정하지 않고 가상의 메모리로 사용하다가 교체할 경우!!
기존에 운영중인 코드 수정 없이 교체하려고 한다
=> SpringConfiguration에 데이터 repository의 return값만 바꿔준다!

별개로 @Autowired는 spring이 관리하는 개체에서만 동작한다.
스프링이 관리하는 객체라는 건 해당 프로젝트의 하위로 존재할 때!
(com.example.inflearn1 하위에 존재하는 상황에서 @Service등이 붙어있거나 config에서 빈으로 등록해줬을 때!)

===============================================================================

DB는 H2 설치 후 실행시키고,
URL 부분에서 오류가 난다면 앞에 IP 부분을 'localhost'로 바꿔주면 된다.

DB를 생성한 후에는 해당 파일을 가져다 쓰면 여러 곳에서 사용해 오류가 날 수 있으므로
jdbc:h2:~/test => jdbc:h2:tcp://localhost/~/test 로 바꿔서 사용!
이렇게 해야 소켓을 통해 여러 곳에서 사용 가능함


drop tablet if exists member CASCADE;

create table member
(
     id bigint generated by default as identity,
     name varchar(255),
     primary key (id)
)

===============================================================================

스프링이 좋은 이유!

다형성을 활용하기 때문에!!
구현체를 이용해서 바꿔 끼는 형식으로 진행 - 스프링 컨테이너가 해당 부분을 편리하게 지원함



